<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Zorn Pentatonic Renderer - p5.js Oil Painting Version</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: 'Monaco', 'Courier New', monospace;
      background: #1a1a1a;
      color: #f0f0f0;
    }
    h1 {
      text-align: center;
      color: #ff6b35;
    }
    .controls {
      text-align: center;
      margin: 20px;
      padding: 20px;
      background: #2a2a2a;
      border-radius: 8px;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      margin: 5px;
      cursor: pointer;
      background: #ff6b35;
      color: white;
      border: none;
      border-radius: 4px;
      font-family: inherit;
    }
    button:hover {
      background: #ff8555;
    }
    #canvasContainer {
      text-align: center;
      margin-top: 20px;
    }
    .slider-container {
      margin: 15px 0;
      display: inline-block;
      width: 300px;
    }
    .slider-container label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    input[type="range"] {
      width: 100%;
      cursor: pointer;
    }
    .preset-buttons {
      margin: 10px 0;
    }
    .preset-btn {
      padding: 8px 16px;
      font-size: 14px;
      margin: 3px;
      background: #444;
    }
    .preset-btn:hover {
      background: #666;
    }
    .preset-btn.active {
      background: #ff6b35;
    }
  </style>
</head>
<body>
  <h1>ðŸŽ¨ Zorn Pentatonic Oil Painting Renderer - p5.js Version</h1>

  <div class="controls">
    <button onclick="loadNotesAndPaint()">ðŸŽ¨ Load Notes & Paint</button>
    <button onclick="clearPainting()">ðŸ§¹ Clear Canvas</button>

    <br><br>

    <div class="preset-buttons">
      <strong>Density Presets:</strong><br>
      <button class="preset-btn" onclick="setDensity('low')">Low (Fast)</button>
      <button class="preset-btn active" onclick="setDensity('medium')">Medium</button>
      <button class="preset-btn" onclick="setDensity('high')">High (Slow)</button>
      <button class="preset-btn" onclick="setDensity('ultra')">Ultra (Very Slow)</button>
    </div>

    <br>

    <div class="slider-container">
      <label>Strokes per Note: <span id="strokesValue">15</span></label>
      <input type="range" id="strokesSlider" min="1" max="100" value="15" oninput="updateSliders()">
    </div>

    <div class="slider-container">
      <label>Bristles per Stroke: <span id="bristlesValue">20</span></label>
      <input type="range" id="bristlesSlider" min="5" max="80" value="20" oninput="updateSliders()">
    </div>

    <br>
    <div style="margin-top: 10px; color: #aaa; font-size: 12px;">
      Total strokes: <span id="totalStrokes">555</span> |
      Painting progress: <span id="progress">0</span>/<span id="totalNotes">37</span> notes
    </div>
  </div>

  <div id="canvasContainer"></div>

  <script>
    // Global variables
    let notes = [];
    let canvas;
    let painting = false;
    let currentNoteIndex = 0;
    let currentStrokeIndex = 0;
    let brushSize = 12;

    // Density settings (inspired by Javier's maxColorDiff concept)
    let strokesPerNote = 15;
    let bristlesPerStroke = 20;

    const DENSITY_PRESETS = {
      low: { strokes: 5, bristles: 10 },
      medium: { strokes: 15, bristles: 20 },
      high: { strokes: 50, bristles: 40 },
      ultra: { strokes: 100, bristles: 60 }
    };

    // Zorn Palette
    const ZORN_PALETTE = {
      YELLOW_OCHRE: [227, 168, 87],
      VERMILION: [217, 96, 59],
      IVORY_BLACK: [41, 36, 33],
      TITANIUM_WHITE: [252, 250, 242]
    };

    const CANVAS_BASE = [242, 235, 220];

    // p5.js sketch
    const sketch = function(p) {

      p.setup = function() {
        // Create canvas
        const cnv = p.createCanvas(1200, 600);
        cnv.parent('canvasContainer');

        // Setup
        p.background(CANVAS_BASE);
        p.strokeCap(p.SQUARE);
        p.colorMode(p.RGB, 255);

        console.log('âœ… p5.js canvas ready');
      };

      p.draw = function() {
        // Auto-paint notes with multiple strokes per note
        if (painting && currentNoteIndex < notes.length) {
          const note = notes[currentNoteIndex];

          // Paint multiple strokes for this note
          paintNoteStroke(note, currentNoteIndex, currentStrokeIndex);
          currentStrokeIndex++;

          // Move to next note when all strokes are done
          if (currentStrokeIndex >= strokesPerNote) {
            currentStrokeIndex = 0;
            currentNoteIndex++;

            // Update progress display
            document.getElementById('progress').textContent = currentNoteIndex;
          }

          if (currentNoteIndex >= notes.length) {
            painting = false;
            console.log('âœ… Painting complete!');
            console.log(`Total strokes painted: ${notes.length * strokesPerNote}`);
          }
        }
      };

      //
      // Paint a single stroke for a note (called multiple times per note)
      //
      function paintNoteStroke(note, noteIndex, strokeIndex) {
        // Map note position to canvas
        const totalDuration = notes[notes.length - 1].start_time + notes[notes.length - 1].duration;
        const baseX = 50 + (note.start_time / totalDuration) * (p.width - 100);
        const baseY = p.height / 2 + (60 - note.pitch) * 10;

        // Add variation to position for multiple strokes
        const variation = 35 + (note.velocity_value || 0.5) * 50; // Increased variation
        const x = baseX + p.random(-variation, variation);
        const y = baseY + p.random(-variation, variation);

        // Get color from pitch
        const color = getPaletteColor(note.pitch);

        // Size based on velocity with variation - MUCH LARGER like Javier's
        let size = 60 + (note.velocity_value || 0.5) * 120; // Was 30 + 60, now 60 + 120
        size *= p.random(0.6, 1.5); // Bigger variation range

        // Technique-based rendering
        const technique = note.technique || 'regular';

        switch(technique) {
          case 'vibrato':
            drawVibratoStroke(x, y, size, color);
            break;
          case 'bend':
            drawBendStroke(x, y, size, color);
            break;
          case 'slide':
            drawSlideStroke(x, y, size, color);
            break;
          case 'staccato':
            drawStaccatoStroke(x, y, size, color);
            break;
          case 'legato':
            drawLegatoStroke(x, y, size, color);
            break;
          default:
            drawOilBrushStroke(x, y, size, color);
        }
      }

      //
      // Oil brush stroke using p5.js bristle simulation
      //
      function drawOilBrushStroke(x, y, size, baseColor) {
        const nBristles = bristlesPerStroke; // Use density setting
        const angle = p.random(p.TWO_PI);
        const length = size * (1.2 + p.random(0.8)); // LONGER bristles (was 0.8 + 0.4)

        // Create bristles
        for (let i = 0; i < nBristles; i++) {
          // Spread bristles perpendicular to stroke - WIDER spread
          const spread = (i / nBristles - 0.5) * size * 1.2; // Was 0.6, now 1.2
          const perpAngle = angle + p.HALF_PI;

          const startX = x + p.cos(perpAngle) * spread;
          const startY = y + p.sin(perpAngle) * spread;

          // Bristle path with organic variation
          const bristleAngle = angle + p.random(-0.4, 0.4); // More angle variation
          const bristleLength = length * (0.6 + p.random(0.8)); // More length variation

          // Color variation per bristle
          const deltaBrightness = p.random(-25, 25); // More color variation
          const bristleColor = p.color(
            p.constrain(baseColor[0] + deltaBrightness, 0, 255),
            p.constrain(baseColor[1] + deltaBrightness, 0, 255),
            p.constrain(baseColor[2] + deltaBrightness, 0, 255),
            p.random(80, 220) // Wider alpha range
          );

          // Draw bristle with chain segments (simulating physics)
          drawBristleChain(startX, startY, bristleAngle, bristleLength, bristleColor);
        }
      }

      //
      // Draw a single bristle as a chain of segments
      //
      function drawBristleChain(x, y, angle, length, col) {
        const nSegments = 6; // More segments for smoother curves
        const segmentLength = length / nSegments;

        p.stroke(col);
        p.noFill();

        let currentX = x;
        let currentY = y;
        let currentAngle = angle;

        for (let i = 0; i < nSegments; i++) {
          // Add organic variation to angle
          currentAngle += p.random(-0.25, 0.25);

          const nextX = currentX + p.cos(currentAngle) * segmentLength;
          const nextY = currentY + p.sin(currentAngle) * segmentLength;

          // Thickness decreases along bristle - THICKER overall
          const thickness = (4 + p.random(3)) * (1 - i / nSegments * 0.4); // Was 3 + 2, now 4 + 3
          p.strokeWeight(thickness);

          p.line(currentX, currentY, nextX, nextY);

          currentX = nextX;
          currentY = nextY;
        }
      }

      //
      // Vibrato technique
      //
      function drawVibratoStroke(x, y, size, color) {
        const numWaves = 4;
        const amplitude = size * 0.4;

        p.stroke(color[0], color[1], color[2], 180);
        p.strokeWeight(size * 0.15);
        p.noFill();

        p.beginShape();
        for (let i = 0; i <= numWaves * 8; i++) {
          const t = i / (numWaves * 8);
          const px = x - size + t * size * 2;
          const py = y + p.sin(i * p.PI / 4) * amplitude;
          p.vertex(px, py);
        }
        p.endShape();

        // Add impasto at center
        drawImpasto(x, y, size * 0.4, color);
      }

      //
      // Bend technique
      //
      function drawBendStroke(x, y, size, color) {
        const startY = y + size * 0.5;
        const endY = y - size * 0.5;
        const controlX = x + size * 0.6;

        p.stroke(color[0], color[1], color[2], 200);
        p.strokeWeight(size * 0.12);
        p.noFill();

        p.bezier(
          x, startY,
          controlX, (startY + endY) / 2,
          controlX, (startY + endY) / 2,
          x, endY
        );

        // Arrow
        const arrowSize = size * 0.15;
        p.line(x - arrowSize, endY + arrowSize, x, endY);
        p.line(x + arrowSize, endY + arrowSize, x, endY);
      }

      //
      // Slide technique
      //
      function drawSlideStroke(x, y, size, color) {
        const angle = p.random() > 0.5 ? -p.PI / 4 : p.PI / 4;
        const length = size * 1.5;

        const startX = x - p.cos(angle) * length / 2;
        const startY = y - p.sin(angle) * length / 2;
        const endX = x + p.cos(angle) * length / 2;
        const endY = y + p.sin(angle) * length / 2;

        p.stroke(color[0], color[1], color[2], 180);
        p.strokeWeight(size * 0.15);
        p.line(startX, startY, endX, endY);

        // Motion trails
        for (let i = 0; i < 3; i++) {
          const offset = (i - 1) * size * 0.25;
          p.stroke(color[0], color[1], color[2], 60 - i * 20);
          p.strokeWeight(size * 0.08);
          p.line(startX + offset, startY, endX + offset, endY);
        }
      }

      //
      // Staccato technique
      //
      function drawStaccatoStroke(x, y, size, color) {
        const numDots = 3 + Math.floor(p.random(3));

        p.fill(color[0], color[1], color[2], 220);
        p.noStroke();

        for (let i = 0; i < numDots; i++) {
          const angle = (i / numDots) * p.TWO_PI;
          const distance = size * 0.4;
          const dotX = x + p.cos(angle) * distance;
          const dotY = y + p.sin(angle) * distance;
          const dotRadius = size * 0.15;

          p.ellipse(dotX, dotY, dotRadius * 2);
        }

        // Center dot
        p.ellipse(x, y, size * 0.4);
      }

      //
      // Legato technique
      //
      function drawLegatoStroke(x, y, size, color) {
        const length = size * 1.8;
        const width = size * 0.6;

        p.noStroke();

        for (let i = 0; i < 15; i++) {
          const offset = (i / 15 - 0.5) * length;
          const localWidth = width * (1 - Math.abs(offset / length) * 0.5);
          const alpha = 40 - i * 2;

          p.fill(color[0], color[1], color[2], alpha);
          p.ellipse(x + offset, y, localWidth * 2);
        }
      }

      //
      // Impasto technique
      //
      function drawImpasto(x, y, radius, color) {
        const numLayers = 12;

        for (let layer = 0; layer < numLayers; layer++) {
          const layerRadius = radius * (1 - layer * 0.05);
          const alpha = 200 * (0.7 + layer * 0.025);

          p.fill(color[0], color[1], color[2], alpha);
          p.noStroke();

          // Irregular shape
          p.beginShape();
          const numPoints = 8;
          for (let i = 0; i < numPoints; i++) {
            const angle = (i / numPoints) * p.TWO_PI;
            const variation = 0.8 + p.random(0.4);
            const px = x + p.cos(angle) * layerRadius * variation;
            const py = y + p.sin(angle) * layerRadius * variation;
            p.vertex(px, py);
          }
          p.endShape(p.CLOSE);
        }
      }

      //
      // Get palette color from pitch
      //
      function getPaletteColor(pitch) {
        const normalized = (pitch % 12) / 12;

        if (normalized < 0.25) return ZORN_PALETTE.YELLOW_OCHRE;
        else if (normalized < 0.5) return ZORN_PALETTE.VERMILION;
        else if (normalized < 0.75) return ZORN_PALETTE.IVORY_BLACK;
        else return ZORN_PALETTE.TITANIUM_WHITE;
      }
    };

    // Create p5.js instance
    const myp5 = new p5(sketch);

    //
    // Set density preset
    //
    function setDensity(preset) {
      const settings = DENSITY_PRESETS[preset];
      strokesPerNote = settings.strokes;
      bristlesPerStroke = settings.bristles;

      // Update sliders
      document.getElementById('strokesSlider').value = strokesPerNote;
      document.getElementById('bristlesSlider').value = bristlesPerStroke;
      updateSliders();

      // Update button states
      document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');

      console.log(`ðŸŽ¨ Density set to ${preset}: ${strokesPerNote} strokes/note, ${bristlesPerStroke} bristles/stroke`);
    }

    //
    // Update slider values
    //
    function updateSliders() {
      strokesPerNote = parseInt(document.getElementById('strokesSlider').value);
      bristlesPerStroke = parseInt(document.getElementById('bristlesSlider').value);

      document.getElementById('strokesValue').textContent = strokesPerNote;
      document.getElementById('bristlesValue').textContent = bristlesPerStroke;

      // Update total strokes display
      const totalStrokes = notes.length * strokesPerNote || strokesPerNote * 37;
      document.getElementById('totalStrokes').textContent = totalStrokes;
    }

    //
    // Load notes and start painting
    //
    async function loadNotesAndPaint() {
      try {
        const response = await fetch('1207(1)_notes.json');
        notes = await response.json();
        console.log(`âœ… Loaded ${notes.length} notes`);

        // Update UI
        document.getElementById('totalNotes').textContent = notes.length;
        document.getElementById('progress').textContent = 0;
        updateSliders();

        // Reset
        currentNoteIndex = 0;
        currentStrokeIndex = 0;
        myp5.background(CANVAS_BASE);

        // Start painting
        painting = true;
        console.log(`ðŸŽ¨ Starting oil painting with ${strokesPerNote} strokes/note, ${bristlesPerStroke} bristles/stroke`);
        console.log(`Total strokes: ${notes.length * strokesPerNote}`);
      } catch (error) {
        console.error('âŒ Error loading notes:', error);
        alert('Errore nel caricamento note! Verifica che 1207(1)_notes.json esista.');
      }
    }

    //
    // Clear painting
    //
    function clearPainting() {
      myp5.background(CANVAS_BASE);
      painting = false;
      currentNoteIndex = 0;
      currentStrokeIndex = 0;
      document.getElementById('progress').textContent = 0;
      console.log('ðŸ§¹ Canvas cleared');
    }

    // Initialize on load
    window.addEventListener('load', () => {
      updateSliders();
    });
  </script>
</body>
</html>
